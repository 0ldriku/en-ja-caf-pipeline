#!/usr/bin/env python3
"""
Probe script: compare baseline auto CAF vs VAD-refined auto CAF against manual CAF.

Focus:
  - Gold-40 set from annotation/selected_files.json
  - Overall / ST1 / ST2
  - All 9 CAF measures, with emphasis on MCPD

Outputs:
  - rq3_vad_probe_summary.csv
  - rq3_vad_probe_mcpd_file_deltas.csv
"""

from __future__ import annotations

import json
from pathlib import Path

import numpy as np
import pandas as pd
from scipy import stats

BASE = Path(__file__).resolve().parents[2]
RESULTS = BASE / "results"
ANNOT = BASE / "annotation"

BASELINE_AUTO = RESULTS / "qwen3_filler_mfa_beam100" / "caf_results_beam100.csv"
MANUAL = RESULTS / "manual_260212" / "caf_results_manual.csv"
SELECTED = ANNOT / "selected_files.json"

CAF_MEASURES = ["AR", "SR", "MLR", "MCPR", "ECPR", "PR", "MCPD", "ECPD", "MPD"]


def icc_2_1(x: np.ndarray, y: np.ndarray) -> float:
    n = len(x)
    k = 2
    data = np.column_stack([x, y])
    gm = data.mean()
    rm = data.mean(axis=1)
    cm = data.mean(axis=0)
    ssr = k * np.sum((rm - gm) ** 2)
    ssc = n * np.sum((cm - gm) ** 2)
    sst = np.sum((data - gm) ** 2)
    sse = sst - ssr - ssc
    msr = ssr / (n - 1)
    msc = ssc / (k - 1)
    mse = sse / ((n - 1) * (k - 1))
    denom = msr + (k - 1) * mse + (k / n) * (msc - mse)
    if abs(denom) < 1e-15:
        return 1.0
    return float((msr - mse) / denom)


def with_file_id(df: pd.DataFrame) -> pd.DataFrame:
    out = df.copy()
    out["file_id"] = out["file"].str.replace(".TextGrid", "", regex=False)
    return out


def compute_rows(merged: pd.DataFrame, track: str, subset: str) -> list[dict]:
    rows = []
    for m in CAF_MEASURES:
        a = merged[f"{m}_auto"].to_numpy(dtype=float)
        b = merged[f"{m}_manual"].to_numpy(dtype=float)
        r, rp = stats.pearsonr(a, b)
        rho, rhop = stats.spearmanr(a, b)
        diff = a - b
        rows.append(
            {
                "track": track,
                "subset": subset,
                "measure": m,
                "n": len(merged),
                "mean_auto": round(float(np.mean(a)), 4),
                "mean_manual": round(float(np.mean(b)), 4),
                "pearson_r": round(float(r), 3),
                "pearson_p": float(rp),
                "spearman_rho": round(float(rho), 3),
                "spearman_p": float(rhop),
                "icc_2_1": round(float(icc_2_1(a, b)), 3),
                "bias": round(float(np.mean(diff)), 4),
                "mae": round(float(np.mean(np.abs(diff))), 4),
            }
        )
    return rows


def main() -> None:
    import argparse

    ap = argparse.ArgumentParser()
    ap.add_argument(
        "--auto-vad-csv",
        required=True,
        help="Path to VAD-refined auto CAF CSV generated by caf_calculator_vad.py",
    )
    ap.add_argument(
        "--out-dir",
        default=str(Path(__file__).resolve().parent),
        help="Output directory (default: this script directory)",
    )
    args = ap.parse_args()

    out_dir = Path(args.out_dir)
    out_dir.mkdir(parents=True, exist_ok=True)

    selected = json.loads(SELECTED.read_text(encoding="utf-8"))
    gold40 = set(selected["all_selected"])

    auto_base = with_file_id(pd.read_csv(BASELINE_AUTO))
    auto_vad = with_file_id(pd.read_csv(args.auto_vad_csv))
    manual = with_file_id(pd.read_csv(MANUAL))

    manual_gold = manual[manual["file_id"].isin(gold40)].copy()
    manual_gold["task"] = np.where(manual_gold["file_id"].str.contains("ST1"), "ST1", "ST2")

    base_gold = auto_base[auto_base["file_id"].isin(gold40)].copy()
    base_gold["task"] = np.where(base_gold["file_id"].str.contains("ST1"), "ST1", "ST2")

    vad_gold = auto_vad[auto_vad["file_id"].isin(gold40)].copy()
    vad_gold["task"] = np.where(vad_gold["file_id"].str.contains("ST1"), "ST1", "ST2")

    merged_base = pd.merge(base_gold, manual_gold, on="file_id", suffixes=("_auto", "_manual"))
    merged_base["task"] = np.where(merged_base["file_id"].str.contains("ST1"), "ST1", "ST2")

    merged_vad = pd.merge(vad_gold, manual_gold, on="file_id", suffixes=("_auto", "_manual"))
    merged_vad["task"] = np.where(merged_vad["file_id"].str.contains("ST1"), "ST1", "ST2")

    rows: list[dict] = []
    rows.extend(compute_rows(merged_base, "baseline_gold40", "Overall"))
    rows.extend(compute_rows(merged_base[merged_base["task"] == "ST1"], "baseline_gold40", "ST1"))
    rows.extend(compute_rows(merged_base[merged_base["task"] == "ST2"], "baseline_gold40", "ST2"))
    rows.extend(compute_rows(merged_vad, "vad_gold40", "Overall"))
    rows.extend(compute_rows(merged_vad[merged_vad["task"] == "ST1"], "vad_gold40", "ST1"))
    rows.extend(compute_rows(merged_vad[merged_vad["task"] == "ST2"], "vad_gold40", "ST2"))

    summary = pd.DataFrame(rows)
    summary_out = out_dir / "rq3_vad_probe_summary.csv"
    summary.to_csv(summary_out, index=False)

    # File-level MCPD deltas for quick diagnosis
    mcpd = pd.merge(
        merged_base[["file_id", "task", "MCPD_auto", "MCPD_manual"]],
        merged_vad[["file_id", "MCPD_auto"]].rename(columns={"MCPD_auto": "MCPD_auto_vad"}),
        on="file_id",
        how="inner",
    )
    mcpd = mcpd.rename(columns={"MCPD_auto": "MCPD_auto_baseline"})
    mcpd["abs_err_baseline"] = (mcpd["MCPD_auto_baseline"] - mcpd["MCPD_manual"]).abs()
    mcpd["abs_err_vad"] = (mcpd["MCPD_auto_vad"] - mcpd["MCPD_manual"]).abs()
    mcpd["abs_err_delta_vad_minus_base"] = mcpd["abs_err_vad"] - mcpd["abs_err_baseline"]
    mcpd_out = out_dir / "rq3_vad_probe_mcpd_file_deltas.csv"
    mcpd.to_csv(mcpd_out, index=False)

    print("=" * 80)
    print("RQ3 VAD PROBE (Gold-40)")
    print("=" * 80)
    for subset in ["Overall", "ST1", "ST2"]:
        b = summary[(summary["track"] == "baseline_gold40") & (summary["subset"] == subset) & (summary["measure"] == "MCPD")].iloc[0]
        v = summary[(summary["track"] == "vad_gold40") & (summary["subset"] == subset) & (summary["measure"] == "MCPD")].iloc[0]
        print(
            f"{subset}: MCPD r {b['pearson_r']:.3f}->{v['pearson_r']:.3f}, "
            f"ICC {b['icc_2_1']:.3f}->{v['icc_2_1']:.3f}, "
            f"MAE {b['mae']:.3f}->{v['mae']:.3f}"
        )
    print(f"Saved: {summary_out}")
    print(f"Saved: {mcpd_out}")


if __name__ == "__main__":
    main()
